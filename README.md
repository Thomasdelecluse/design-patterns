# Introduction
Ce d√©p√¥t a √©t√© cr√©√© dans le but de fournir des exemples concrets et facilement compr√©hensibles de divers design patterns. Chaque design pattern est impl√©ment√© dans un r√©pertoire s√©par√© avec des exemples de code et des instructions sur la fa√ßon de les utiliser. üòÑ 

# Utilisation
Chaque design pattern se trouve dans un r√©pertoire s√©par√© avec son propre fichier main ‚ñ∂Ô∏è pour lancer l'exemple de code. 

## Observer
Le pattern Observer permet de d√©finir une relation de d√©pendance entre objets de sorte que lorsqu'un objet change d'√©tat, tous ses d√©pendants en sont inform√©s et mis √† jour automatiquement.

R√©pertoire : observer
Description : Impl√©mentation d'un mod√®le de publication/abonnement o√π les observateurs peuvent s'abonner et se d√©sabonner dynamiquement.

## Decorator
Le pattern Decorator permet d'attacher dynamiquement des responsabilit√©s suppl√©mentaires √† un objet. Les d√©corateurs fournissent une alternative flexible √† la sous-classe pour l'extension des fonctionnalit√©s.

R√©pertoire : decorator
Description : Exemple montrant comment ajouter des fonctionnalit√©s √† un objet de mani√®re flexible sans modifier la structure de base de l'objet.

## Factory
Le pattern Factory fournit une interface pour cr√©er des objets dans une superclasse, mais permet aux sous-classes de modifier le type d'objets qui seront cr√©√©s.

R√©pertoire : factory
Description : Impl√©mentation d'une m√©thode de cr√©ation d'objets qui permet de diff√©rer l'instanciation aux sous-classes.

## Strategy
Le pattern Strategy permet de d√©finir une famille d'algorithmes, de les encapsuler chacun et de les rendre interchangeables. Le pattern Strategy permet de rendre l'algorithme ind√©pendant du client qui l'utilise.

R√©pertoire : strategy
Description : Exemple d√©montrant comment des algorithmes interchangeables peuvent √™tre s√©lectionn√©s et utilis√©s dynamiquement.
